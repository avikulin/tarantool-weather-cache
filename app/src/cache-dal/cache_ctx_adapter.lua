---
--- Generated by EmmyLua(https://github.com/EmmyLua)
--- Created by andreyv.
--- DateTime: 21.03.2024 00:54
---
local cartridge = require('cartridge')
local date = require('datetime')
local json = require('json')
local log = require('log').new("cache-context-adapter")
log.cfg{ level='info'}

local cache_dal_metadata = require('app.src.config.cache_dal_metadata')

local function get_number_of_cached_items()
    local count = box.space.request_cache:count()
    log.info("Requesting number of cached items: "..count)
    return count
end

local function get_most_aged_item_id()
    local items = box.space.request_cache.index.created_moment_idx:select({}, { iterator = box.index.EQ, limit = 1})

    if (items ~= nil and #items ~= 0) then
        local result = items[1]
        log.info("Most aged item in cache: "..json.encode(result:tomap({ names_only = true })))
        return  result:transform(3,5):tomap({ names_only = true })
    end

    log.info("No items found")
    return nil
end

local function get_less_usage_item_id()
    local items = box.space.request_cache.index.usage_rating_idx:select({}, { iterator = box.index.EQ, limit = 1})

    if (items ~= nil and #items ~= 0) then
        local result = items[1]
        log.info("Less used item in cache: "..json.encode(result:tomap({ names_only = true })))
        return  result:transform(3,5):tomap({ names_only = true })
    end

    log.info("No items found")
    return nil
end

local function get_most_late_accessed_item_id()
    local items = box.space.request_cache.index.last_access_moment:select({}, { iterator = box.index.EQ, limit = 1})

    if (items ~= nil and #items ~= 0) then
        local result = items[1]
        log.info("Most lately accessed item in cache: "..json.encode(result:tomap({ names_only = true })))

        return  result:transform(3,5):tomap({ names_only = true })
    end

    log.info("No items found")
    return nil
end

local function cache_evict(request_key, request_path)
    if (request_key == nil or request_path == nil) then
        error("Null-references parameters passed")
    end
    log.info("Trying to delete item: id = "..request_key..", path = "..request_path)
    local result = box.space.request_cache:delete({request_key, request_path})
    log.info("Success")
    return result
end

local function calculate_latency_in_seconds(start_moment, finish_moment)
    if (start_moment == nil or finish_moment == nil) then
        error("Null-reference parameter(s) passed")
    end

    local start = start_moment:totable()
    log.info("Start moment: "..json.encode(start))

    local finish = finish_moment:totable()
    log.info("Finish moment: "..json.encode(finish))

    local hours_diff = finish['hour'] - start['hour']
    local minutes_diff = finish['min'] - start['min']
    local seconds_diff = finish['sec'] - start['sec']

    local latency = seconds_diff + minutes_diff * 60 + hours_diff * 3600
    log.info("Calculating latency (%s -> %s): hours = %d, minutes = %d, seconds = %d, latency = %d sec.",
              tostring(start_moment), tostring(finish_moment),
              hours_diff, minutes_diff, seconds_diff, latency)
    return latency
end

local function calculate_ttl(item)
    local global_cfg = cartridge.config_get_deepcopy()
    local cache_dal_cfg = global_cfg[cache_dal_metadata.get_cfg_root_key()]
    if (cache_dal_cfg == nil) then
        error("Empty cluster configuration at section <"
            ..cache_dal_metadata.get_cfg_root_key()..">")
    end

    local ttl_limit = cache_dal_cfg[cache_dal_metadata.get_cfg_ttl_key()]
    if (ttl_limit == 0) then
        return -1 --если TTL не установлен, то просто возвращаем -1
    end

    local created_moment = item['created_moment']
    local cached_latency_actual = calculate_latency_in_seconds(created_moment, date.now())

    log.info("Check TTL for item {%s, %s}: created = %s, actual = %s, latency = %d sec., limit = %d sec.",
            item['request_key'], item['request_path'],
            tostring(created_moment), tostring(date.now()), cached_latency_actual, ttl_limit
    )

    return math.max(ttl_limit - cached_latency_actual, 0)
end

local function process_eviction_on_put()
    local global_cfg = cartridge.config_get_deepcopy()
    local cache_dal_cfg = global_cfg[cache_dal_metadata.get_cfg_root_key()]
    if (cache_dal_cfg == nil) then
        error("Empty cluster configuration at section <"
            ..cache_dal_metadata.get_cfg_root_key()..">")
    end

    local limit = cache_dal_cfg[cache_dal_metadata.get_cfg_cache_size_key()]
    local strategy_name = cache_dal_cfg[cache_dal_metadata.get_cfg_cache_strategy_key()]

    local actual_size = get_number_of_cached_items()
    if (actual_size < limit) then
        log.info("There is no need to evict items from cache: current size = %d", actual_size)
        return
    end

    local item_to_evict_id = {}
    if (strategy_name == cache_dal_metadata.get_cfg_lru_policy_name()) then
        item_to_evict_id = get_less_usage_item_id()
    end

    if (strategy_name == cache_dal_metadata.get_cfg_lra_policy_name()) then
        item_to_evict_id = get_most_late_accessed_item_id()
    end

    if (strategy_name == cache_dal_metadata.get_cfg_fifo_policy_name()) then
        item_to_evict_id = get_most_aged_item_id()
    end

    cache_evict(item_to_evict_id['request_key'], item_to_evict_id['request_path'])
    log.info("Eviction performed: strategy = <%s>, object = %s", strategy_name, json.encode(item_to_evict_id))
end

local function process_eviction_on_get(item)
    if (item == nil) then
        error("process_eviction_on_get: Null-object passed")
    end

    local ttl_actual = calculate_ttl(item)
    log.info("Check TTL for item {%s, %s}: %d", item['request_key'], item['request_path'], ttl_actual)

    if (ttl_actual == -1) then
        return item --если TTL не установлен, то просто возвращаем значение
    end

    -- если TTL установлен и истек у данной сущности, то: а) удаляем ее из БД, б) возвращаем NULL
    if (ttl_actual == 0) then
        cache_evict(item['request_key'], item['request_path'])
        return nil
    end

    -- если TTL установлен и еще не истек у данной сущности, то возвращаем ееё
    item[cache_dal_metadata.get_cfg_ttl_key()] = ttl_actual
    return item
end

local function cache_put(item)
    if (item == nil) then
        error("cache_put: Null-object passed")
    end

    -- проводим вытеснение из кэша
    process_eviction_on_put()

    -- загружаем в кэш новый элемент
    log.info("New request to put: "..json.encode(item))
    local item_tuple = box.space.request_cache:frommap(item)
    local result = box.space.request_cache:insert(item_tuple)

    if result ~= nil then
        log.info("Result: "..json.encode(result))
    end

    item[cache_dal_metadata.get_cfg_ttl_key()] = calculate_ttl(item)
    return result
end

local function cache_lookup(request_key, request_path)
    if (request_key == nil or request_path == nil) then
        error("cache_lookup: Null-references parameters passed")
    end

    log.info("Processing request: key = "..request_key..", path = "..request_path)

    local affected_tuple = box.space.request_cache:update(
        { request_key, request_path}, -- ключ получаемой записи
        {
            {'+', 5, 1},              -- увеличиваем рейтинг
            {'=', 7, date.now()}      -- проставляем время последнего доступа
        }
    )

    if (affected_tuple ~= nil and #affected_tuple ~= 0) then
        log.info("Item found: "..json.encode(affected_tuple[1]))
        local item = affected_tuple:tomap({ names_only = true })

        -- возвращаем из кэша только неустаревшие сущности (подчищаем в рамках транзакции чтения)
        return process_eviction_on_get(item)
    end

    log.info("No items found")
    return nil
end

return {
    cache_lookup = cache_lookup,
    cache_put = cache_put,
    get_less_usage_item_id = get_less_usage_item_id,
    get_most_aged_item_id = get_most_aged_item_id,
    get_most_late_accessed_item_id = get_most_late_accessed_item_id,
    get_number_of_cached_items = get_number_of_cached_items,
    cache_evict = cache_evict
}
